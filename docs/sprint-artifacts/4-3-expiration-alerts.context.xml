<story-context id="docs/sprint-artifacts/4-3-expiration-alerts.context.xml" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>3</storyId>
    <title>Expiration Alerts</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-12-01</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-3-expiration-alerts.md</sourceStoryPath>
  </metadata>
  <story>
    <asA>a user</asA>
    <iWant>to receive alerts for items nearing expiration</iWant>
    <soThat>I can use them before they go to waste.</soThat>
    <tasks>
        - [ ] Implement backend logic for expiration detection (AC: 1)
        - [ ] Set up `PG Cron` job to periodically check for expiring items.
        - [ ] Implement Supabase function to identify expiring items.
        - [ ] Integrate with Supabase Realtime to push notifications to frontend.
        - [ ] Implement `GET /api/notifications` API endpoint (AC: 1)
        - [ ] Define API route in `app/api/notifications/route.ts`.
        - [ ] Fetch expiring items from Supabase.
        - [ ] Implement frontend notification display (AC: 1)
        - [ ] Integrate with Supabase Realtime client on frontend.
        - [ ] Display in-app notifications on the dashboard.
        - [ ] Create `ActionableAlertCard` component per UX design.
        - [ ] Link notifications to relevant recipes (AC: 2)
        - [ ] Modify notification payload to include recipe IDs or links.
        - [ ] Implement navigation from `ActionableAlertCard` to recipe details.
        - [ ] Implement notification bundling logic (AC: 3)
        - [ ] Group multiple expiring items into a single notification.
        - [ ] Define bundling rules (e.g., daily digest).
        - [ ] Write unit and integration tests for expiration detection and notification API (AC: 1)
        - [ ] Write unit and integration tests for recipe linking in notifications (AC: 2)
        - [ ] Write unit and integration tests for notification bundling logic (AC: 3)
        - [ ] Write E2E tests for the complete notification flow, covering all acceptance criteria (AC: 1, 2, 3)
    </tasks>
  </story>
  <acceptanceCriteria>
    1. Given I have items in my inventory with expiration dates, when items are 2-3 days from expiring, then I receive an in-app notification. (FR4.1)
    2. The notification directly links to recipes using those expiring items (Expiration-to-Inspiration Loop, per UX). (FR4.1, UX)
    3. Notifications are bundled to avoid fatigue (per UX and PRD). (FR4.1, UX, PRD)
  </acceptanceCriteria>
  <artifacts>
    <docs>
        <doc>
            <path>docs/sprint-artifacts/tech-spec-epic-4.md</path>
            <title>Epic Technical Specification: Personalized Suggestions &amp; Alerts</title>
            <section>Data Models and Contracts</section>
            <snippet>This epic primarily relies on the existing `inventory_items` and `users` tables. It introduces a new `notifications` table.</snippet>
        </doc>
        <doc>
            <path>docs/PRD.md</path>
            <title>ibe160 - Product Requirements Document</title>
            <section>FR4.1 - Expiration Alerts</section>
            <snippet>The system notifies the user about items nearing expiration. An in-app notification is generated for items expiring in the next 2-3 days.</snippet>
        </doc>
        <doc>
            <path>docs/architecture.md</path>
            <title>Architecture</title>
            <section>FR Category to Architecture Mapping</section>
            <snippet>Notifications: Frontend components for in-app alerts, PG Cron for triggering alerts, Supabase Realtime for pushing alerts, Resend for email notifications...</snippet>
        </doc>
    </docs>
    <code>
        <artifact>
            <path>app/api/notifications/route.ts</path>
            <kind>api-route</kind>
            <symbol>GET</symbol>
            <lines>N/A (new file)</lines>
            <reason>API endpoint to fetch notifications for the user.</reason>
        </artifact>
        <artifact>
            <path>app/(main)/dashboard/page.tsx</path>
            <kind>ui-page</kind>
            <symbol>DashboardPage</symbol>
            <lines>N/A</lines>
            <reason>This page will display the in-app notifications.</reason>
        </artifact>
        <artifact>
            <path>components/specific/ActionableAlertCard.tsx</path>
            <kind>ui-component</kind>
            <symbol>ActionableAlertCard</symbol>
            <lines>N/A (new file)</lines>
            <reason>Component to display a single notification alert.</reason>
        </artifact>
    </code>
    <dependencies>
        <dependency>
            <name>next</name>
            <version>16+</version>
        </dependency>
        <dependency>
            <name>@supabase/supabase-js</name>
            <version>Latest Stable</version>
        </dependency>
    </dependencies>
  </artifacts>
  <constraints>
    - Background Jobs: PG Cron in Supabase for handling database-related background tasks.
    - Real-time Features: Supabase Realtime for pushing alerts.
  </constraints>
  <interfaces>
    <interface>
      <name>GET /api/notifications</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/notifications</signature>
      <path>app/api/notifications/route.ts</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Multi-layered strategy including Unit Tests (`Jest`, `React Testing Library`), Integration Tests (API routes, database interactions), and End-to-End (E2E) Tests (`Playwright`, `Cypress`), focusing on user-centric scenarios.</standards>
    <locations>
      - `tests/`
    </locations>
    <ideas>
        - (Integration) Test the `PG Cron` job to ensure it creates notifications correctly.
        - (Integration) Test the Supabase Realtime integration to ensure the frontend receives notifications.
        - (E2E) Simulate a user receiving an expiration alert and clicking on it to see recipe suggestions.
    </ideas>
  </tests>
</story-context>
